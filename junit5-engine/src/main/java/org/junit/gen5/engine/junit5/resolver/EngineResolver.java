/*
 * Copyright 2015-2016 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v1.0 which
 * accompanies this distribution and is available at
 *
 * http://www.eclipse.org/legal/epl-v10.html
 */

package org.junit.gen5.engine.junit5.resolver;

import java.util.Optional;

import org.junit.gen5.engine.DiscoverySelector;
import org.junit.gen5.engine.EngineDiscoveryRequest;
import org.junit.gen5.engine.TestDescriptor;
import org.junit.gen5.engine.TestEngine;
import org.junit.gen5.engine.discovery.UniqueIdSelector;
import org.junit.gen5.engine.junit5.JUnit5TestEngine;
import org.junit.gen5.engine.support.descriptor.EngineDescriptor;

/**
 * The {@code EngineResolver} is a special resolver. In contradiction to any
 * {@link TestResolver}, it does not resolve any children, as the
 * {@link EngineDescriptor} will be generated by the {@link TestEngine}
 * itself and needs not to be created.
 *
 * <p>The {@code EngineResolver} is necessary only for the resolution of the
 * {@link UniqueIdSelector} from the {@link EngineDiscoveryRequest}. It acts
 * as an entry point for these selectors, consumes the first part of any
 * unique id passed in, and passes the remaining parts to the
 * {@link TestResolverRegistry} to continue the resolution.
 *
 * @since 5.0
 */
public class EngineResolver extends JUnit5TestResolver {
	private static final String RESOLVER_ID = "engine";

	@Override
	public void resolveAllFrom(TestDescriptor parent, EngineDiscoveryRequest discoveryRequest) {
		if (parent.isRoot()) {
			// @formatter:off
            discoveryRequest.getSelectorsByType(UniqueIdSelector.class).stream()
                    .map(UniqueIdSelector::getUniqueId)
                    .map(UniqueId::from)
                    .filter(uid -> !uid.isEmpty())
                    .distinct()
                    .sorted()
                    .forEach(uniqueId -> resolveUniqueId(parent, uniqueId, discoveryRequest));
            // @formatter:on
		}
	}

	@Override
	public void resolveUniqueId(TestDescriptor parent, UniqueId uniqueId, EngineDiscoveryRequest discoveryRequest) {
		if (uniqueId.currentKey().equals(RESOLVER_ID) && uniqueId.currentValue().equals(JUnit5TestEngine.ENGINE_ID)) {
			// TODO Clarify if it is sufficient to check on the unique id
			//      and if it is always guaranteed that this will only match
			//      if the parent is the engine descriptor.
			//      We could also guarantee that the parent is always the root
			//      (engine descriptor) by iterating over the parents like that:
			//      TestDescriptor root = parent;
			//      for (; !root.isRoot(); root = root.getParent().get());
			getTestResolverRegistry().resolveUniqueId(parent, uniqueId.getRemainder(), discoveryRequest);
		}
	}

	@Override
	public Optional<TestDescriptor> fetchBySelector(DiscoverySelector selector, TestDescriptor root) {
		return Optional.empty();
	}
}
